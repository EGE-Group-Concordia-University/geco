// $Id: ECProcess.cc 39 2015-01-09 13:09:42Z wuthrich $
// ---------------------------------------------------------------
//
// Definition of the class gecoProcess
//
// (c) Rolf Wuthrich
//     2015 - 2020 Concordia University
//
// author:  Rolf Wuthrich
// email:   rolf.wuthrich@concordia.ca
// version: v1 ($Revision: 39 $)
//
// This software is copyright under the BSD license
//  
// ---------------------------------------------------------------
// history:
// ---------------------------------------------------------------
// Date       Modification                     Author
// ---------------------------------------------------------------
// 10.10.2015 Creation                         R. Wuthrich
// 28.11.2020 Added doxygen documentation      R. Wuthrich
//
// ---------------------------------------------------------------

#include <cstring>
#include <sys/time.h>
#include <tcl.h>
#include "gecoProcess.h"
#include "gecoApp.h"

#include <iostream>

using namespace std;

// -------------------------------------------------------------------------
//
// Tcl interface


// Command to create a new gecoProcess object
//

int geco_CreateGecoProcessCmd(gecoProcess* proc,
			      int objc, Tcl_Obj *const objv[])
{
  gecoApp* app = proc->getGecoApp();

  // needed in order tclreadline works: don't ask me why....
  int j = 0;

  // checks if -help option was used
  if (objc > 1)
  {
    int i;
      Tcl_GetIndexFromObj(NULL,objv[1], proc->optsTbl(), "", 0, &i);
      if (i==proc->getOptionIndex("-help"))
	{
	  geco_gecoObjCmd((ClientData)proc, app->getInterp(), 2, objv);
	  delete proc;
	  return TCL_OK;
	}
      }

  // Invokes the Tcl command of the gecoProcess in order 
  // to manipulate the geco object.
  // Adds the gecoProcess to the geco loop
  // In case any error occurs, the object is deleted
  if (geco_gecoObjCmd((ClientData)proc, app->getInterp(), objc, objv)==TCL_OK)
    {
      app->addGecoProcess(proc);
      Tcl_ResetResult(app->getInterp());
      Tcl_AppendResult(app->getInterp(), proc->getID(), NULL);
      return TCL_OK;
    }
  else
    {
      delete proc;
      return TCL_ERROR;
    }
}


// -----------------------------------------------------------------------
//
// class gecoProcess : abstract class from which all geco processes derive
//


/**
 * @brief Constructor
 * @param procName name of the gecoProcess
 * @param procOwner owner of the gecoProcess
 * @param procCmd Tcl command associated to the gecoProcess
 * @param App gecoApp in which the gecoProcess lives 
 *
 * The constructor will create a Tcl command via the call of
 * the constructor of gecoObj. It further defines additional
 * subcommands.
*/

gecoProcess::gecoProcess(const char* procName, const char* procOwner,
		         const char* procCmd, gecoApp* App) : 
  gecoObj(procName,procCmd,App),
  nextGecoProc(NULL),
  owner(procOwner),
  status(Waiting),
  activateOnStart(0),
  verbose(1)
{
  activationTime.tv_sec = -1;
  activationTime.tv_usec = -1;
  preProcessScript  = new Tcl_DString;
  postProcessScript = new Tcl_DString;
  Tcl_DStringInit(preProcessScript);
  Tcl_DStringInit(postProcessScript);

  addOption("-verbose", &verbose, "turns on/off messaging to console");
  addOption("-activateOnStart", &activateOnStart,
            "turns on/off activation on start command");
  addOption("-preProcess", preProcessScript, "returns/sets pre-process script");
  addOption("-postProcess", postProcessScript, "returns/sets post-process script");
  addOption("-status", "returns the process status");
}


/**
 * @brief Destructor
*/

gecoProcess::~gecoProcess()
{
  Tcl_DStringFree(preProcessScript);
  Tcl_DStringFree(postProcessScript);
  delete preProcessScript;
  delete postProcessScript;
}


/*! 
 * @copydoc gecoObj::cmd
 *
 * Compared to gecoObj::cmd, gecoProcess::cmd adds the processing of
 * the new subcommands of gecoProcess.
 */

int gecoProcess::cmd(int &i, int objc,Tcl_Obj *const objv[])
{
  // first executes the command options defined in gecoObj
  int index=gecoObj::cmd(i, objc, objv);

  if (index==getOptionIndex("-status"))
    {
      char str[10];
      Tcl_ResetResult(interp);
      sprintf(str, "%s", getStatusStr());
      Tcl_AppendResult(interp, str, NULL);
      i++;
    }

  return index;
}


/*! 
 * @brief Defines how the gecoProcess reacts to external events
 * @param ev gecoEvent to which the gecoProcess has to react
 *
 * The method gecoProcess::handleEvent implements
 * how a gecoProcess reacts to the geco events CmdStart, CmdHold, 
 * CmdResume and CmdStop which are generated by the Tcl commands 'start'
 * 'hold', 'resume' and 'stop'.
 *
 * It takes care to activate the gecoProcess (by calling the 
 * gecoProcess::activate method) when required (following a CmdStart 
 * or a CmdProcessTerminated geco event) and it terminates the
 * gecoProcess (by calling the gecoProcess::terminate method) following
 * a CmdStop event.
 *
 * Reaction to geco events
 * -----------------------
 *
 * geco event            | Action
 * --------------------- | ----------------------
 * CmdStart              | calls gecoProcess::activate and clears gecoEvent if gecoProcess::status is Waiting
 * CmdHold               | sets gecoProcess::status to Hold
 * CmdResume             | sets gecoProcess::status to Active
 * CmdStop               | calls gecoProcess::terminate if gecoProcess::status is Active
 * CmdProcessTerminated  | calls gecoProcess::activate and clears gecoEvent if gecoProcess::status is Waiting
 *
 *
 * Extension by children
 * ---------------------
 * Children must extend this method. Example of extending the method 
 * in a child of gecoProcess:
 * \code
 * // Calls the handleEvent method of the gecoProcess class
 * gecoProcess::handleEvent(ev); 
 *
 * // Add here how the child has to react to the gecoEvent
 * ...
 * \endcode
 */

void gecoProcess::handleEvent(gecoEvent* ev)
{

  if (activateOnStart) 
    {
      if ((status==Waiting)&&(ev->eventLoopStatus())) activate(ev);
    }
  else
    if ((status==Waiting)&&(ev->cmd()==CmdStart))
      {
	activate(ev);
	ev->reset();
      }

  if ((status==Active)&&(ev->cmd()==CmdStop)) 
  {
	  terminate(ev);
	  ev->setCmdEvent(CmdStop, NULL);
  }

  if ((status==Active)&&(ev->cmd()==CmdHold)) status = Hold;
  if ((status==Hold)&&(ev->cmd()==CmdResume)) status = Active;

  // checks if the process should be activated
  if ((status==Waiting)&&(ev->cmd()==CmdProcessTerminated)) 
    {
      activate(ev);
      ev->reset();
    }
}


/*! 
 * @copydoc gecoObj::info
 */

Tcl_DString* gecoProcess::info(const char* frontStr)
{
  return gecoObj::info(frontStr);
}


/*! 
 * @brief Called when the gecoProcess is terminated
 * @param ev gecoEvent that triggered the terminate action
 *
 * This method has to be called whenever the process gets terminated.
 * If the '-verbose' subcommands was defined as ON  will print to the
 * geco console information about the gecoProcess termination.
 *
 * The following actions will take place:
 *
 * * Sets the gecoProcess::status to Terminated
 * * If verbose=1, sends to the geco console a message that the 
 *   gecoProcess was terminated
 * * Leaves in the Tcl interpreter of the gecoApp in which the
 *   gecoProcess lives the ID of the gecoProcess in the Tcl variable ID.
 * * Calls the Tcl postProcessScript of the gecoProcess
 * * Generates the Tk virtual event <<gecoProcessTerminated>>
 * * Sets the gecoEvent ev to CmdProcessTerminated
 */

void gecoProcess::terminate(gecoEvent* ev)
{
  status=Terminated;
  char str[80];
  if (verbose==1)
    Tcl_VarEval(interp,
		"cons \"    terminated ", name," (", getTclCmd(), ").\"", NULL);
  Tcl_SetVar(interp, "ID", objID, 0);
  Tcl_Eval(interp, Tcl_DStringValue(postProcessScript));
  Tcl_Eval(interp, "event generate . <<gecoProcessTerminated>>");
  ev->setCmdEvent(CmdProcessTerminated, this);
}


/*! 
 * @brief Called when the gecoProcess is activated
 * @param ev gecoEvent that triggered the activate action
 *
 * This method has to be called whenever the process gets activated.
 * If the '-verbose' subcommands was defined as ON  will print to the
 * geco console information about the gecoProcess activation.
 *
 * The following actions will take place:
 *
 * * Sets the gecoProcess::status to Active 
 * * If verbose=1, sends to the geco console a message that the 
 *   gecoProcess started
 * * Leaves in the Tcl interpreter of the gecoApp in which the
 *   gecoProcess lives the ID of the gecoProcess in the Tcl variable ID.
 * * Calls the Tcl preProcessScript of the gecoProcess
 * * Stores in gecoProcess::activationTime the current time
 * * Stores in gecoProcess::t_o the time at which the gecoEvent ev was generated
 * * Generates the Tk virtual event <<gecoProcessActivated>>
 */

void gecoProcess::activate(gecoEvent* ev)
{
  status=Active;
  if (verbose==1)
    {
      Tcl_VarEval(interp,
		  "cons \"\n==> starting ", name," (",getTclCmd(),").\"", NULL);
      if (strlen(Tcl_DStringValue(getComment())) > 0)
	Tcl_VarEval(interp, "cons \"    ", Tcl_DStringValue(comment), "\"", NULL);
    }
  Tcl_SetVar(interp, "ID", objID, 0);
  Tcl_Eval(interp, Tcl_DStringValue(preProcessScript));
  gettimeofday(&activationTime, NULL);
  t_o=ev->getT();
  Tcl_Eval(interp, "event generate . <<gecoProcessActivated>>");
}


/*! 
 * @brief Returns the time elapsed since the gecoProcess was activated
 * \return Time in seconds since the gecoProcess was activated 
 */

double gecoProcess::timeSinceActivated()
{
  struct timeval tv;
  gettimeofday(&tv,NULL);
  double t = tv.tv_sec-activationTime.tv_sec+
    (tv.tv_usec - activationTime.tv_usec)*1e-6;
  return t;
}


/*! 
 * @brief Stores internally the Tcl preProcessScript
 * @param PreProcessScript Tcl preProcessScript to store
 */

void gecoProcess::setPreProcessScript(Tcl_DString* PreProcessScript)
{
  Tcl_DStringFree(preProcessScript);
  Tcl_DStringAppend(preProcessScript, Tcl_DStringValue(PreProcessScript), -1);
}


/*! 
 * @brief Stores internally the Tcl postProcessScript
 * @param PostProcessScript Tcl postProcessScript to store
 */

void gecoProcess::setPostProcessScript(Tcl_DString* PostProcessScript)
{
  Tcl_DStringFree(postProcessScript);
  Tcl_DStringAppend(postProcessScript, Tcl_DStringValue(PostProcessScript), -1);
}

