// This may look like C code, but it is really -*- C++ -*-
// $Id: ECApp.h 15 2014-01-03 18:49:04Z wuthrich $
// ---------------------------------------------------------------- 
//                                                                  
// Header file for the class gecoApp
//
// (c) Rolf Wuthrich
//     2015 - 2020 Concordia University
//
// author:  Rolf Wuthrich
// email:   rolf.wuthrich@concordia.ca
// version: v1 ($Revision: 15 $)
//
// This software is copyright under the BSD license
//
// ---------------------------------------------------------------
// history:
// ---------------------------------------------------------------
// Date       Modification                     Author
// ---------------------------------------------------------------
// 12.10.2015 Creation                         R. Wuthrich
// 21.11.2020 Added DOxygen documentation      R. Wuthrich
// ---------------------------------------------------------------

#ifndef gecoApp_SEEN_
#define gecoApp_SEEN_

#include <tcl.h>
#include <tk.h>
#include "gecoEvent.h"

using namespace std;


// -----------------------------------------------------------------------
//
// class gecoApp : a geco application
//

class gecoProcess;            // forward definition
class gecoIOModule;           // forward definition
class gecoPkgHandle;          // forward definition
class gecoTcpServer;          // forward definition


/**
 * @brief A geco application
 * \author Rolf Wuthrich
 * \date 2015-2020
 *
 * \tableofcontents
 *
 * A class to define applications integrating the geco library and a command line interface (CLI)  
 *
 * * Header:    "gecoApp.h"
 * * Inherits:   none
 *
 * Overview
 * --------
 * The gecoApp class setups a Tcl interpreter and a geco process loop. The geco process loop 
 * will be populated with a gecoClock process. The class keeps as well an internal
 * list of loaded gecoIOModule, gecoPkgHandle and gecoTcpServer.
 *
 * Any instance of this class will define and add the following Tcl commands, 
 * to the standard Tcl commands, to the Tcl interpreter run by the instance:
 *
 * Tcl command         | Short description
 * ------------------- | -------------------
 * start               | starts the event loop
 * stop                | stops the event loop
 * hold                | holds the event loop
 * resume              | resumes the event loop
 * ps                  | displays, in a table form, the process loop 
 * terminate processID | terminated the geco process processID
 * remove processID    | removes the geco process processID from the process loop
 * lsiomod             | lists loaded geco IO-modules
 * lstcpserver         | lists running TCP servers
 * loadGecoPkg         | loads a new geco package into the Tcl interpreter
 * unloadGecoPkg       | unloads a geco package from the Tcl interpreter
 * lsgecopkg           | lists loaded geco packages
 *
 * Any instance of this class will define and add the following Tcl variables 
 * to the Tcl interpreter run by the instance:
 *
 * Tcl variable       | Short description
 * -----------------  | --------------------
 * ::geco::license    | read-only variable containing the license of geco
 * ::geco::version    | version number of the geco library
 * ::geco::prompt     | prompt of command line based interface
 * ::geco::commentStr | string used as comment in data files generated by geco (default is '#')
 *
 * Cleanup operations are done in geco_exitHandler(ClientData clientData), which is called at 
 * the moment the Tcl interpreter is destroyed. The Tcl interpreter is destroyed when the Tcl 
 * command 'exit' is passed to the interpreter. Note that in this case, the destructor of gecoApp 
 * will never be invoked. Child classes of gecoApp must perform cleanup operation in a Tcl_ExitProc 
 * to be setup by the Tcp API function Tcl_CreateExitHandler, typically in their constructor.
 *
 * An example usage of the gecoClass can be found in the two applications labtk and labtkd.
 *
 * Tcl Interpreter
 * ---------------
 * The gecoApp class sets up a Tcl interpreter during its construction. The Tcl interpreter 
 * can be accessed with the gecoApp::getInterp method. When the Tcl command 'exit' is invoked,
 * the interpreter will be destroyed and  prior to it the geco_exitHandler(ClientData clientData)
 * function will be called to perform clean up operations.
 *
 * Geco process loop
 * -----------------
 * The gecoApp class sets up the geco process loop during its construction. As first geco process, 
 * a gecoClock process is added to it. The Tcl command 'clk' allows to manipulate this process.  
 * The geco loop is implemented by the Tcl_TimerProc geco_eventLoop(ClientData clientData). 
 * The gecoClock process controls the frequency at which the geco_eventLoop function is called. 
 * The function geco_eventLoop will call successively all gecoProcess loaded in the geco process loop. 
 *
 * A new gecoProcess must be registered to the process loop with the method gecoApp::addGecoProcess. 
 * The new gecoProcess will be added to the end of the process loop. This is automatically taken care of
 * if the function geco_CreateGecoProcessCmd(gecoProcess* proc, int objc, Tcl_Obj *const objv[]) of 
 * the geco library is used to create a new Tcl command associated to a gecoProcess.
 *
 * A gecoProcess can be moved to a new position in the gecoProcess loop with the gecoApp::moveGecoProcess method.
 * The Tcl command 'ps -move', defined by gecoApp, implements this in form of a Tcl command.
 *
 * A gecoProcess no longer needed must be removed from the process loop with the method gecoApp::removeGecoProcess.
 * The Tcl command 'remove' defined by gecoApp implements this in form of a Tcl command. 
 *
 * The geco process loop can be displayed in a table format with the Tcl command 'ps' defined by gecoApp.
 *
 * Geco processes
 * --------------
 *
 * The gecoApp makes available the following geco processes in its Tcl interpreter by calling the method
 * gecoApp::registerNewCmd during it's construction:
 *
 * Geco Process   | Tcl Command
 * -------------- | -------------
 * gecoIO         | io
 * gecoTrigger    | trigger
 * gecoUProc      | uproc
 * gecoGraph      | graph
 * gecoFileStream | filestream
 * gecoMemStream  | memstream
 * gecoTriangle   | triangle
 * gecoSawtooth   | sawtooth
 * gecoStep       | step
 * gecoPulse      | pulse
 * gecoEnd        | end
 *
 * Geco IO-modules
 * ---------------
 * The gecoApp keeps trace of loaded gecoIOModule in an internal list. A new gecoIOModule must be registered 
 * to this list with the method gecoApp::addGecoIOModule. This is taken care of by the gecoIOModule class from 
 * which all gecoIOModule must derive.
 *
 * A gecoIOModule no longer needed must be removed from the internal list with the method
 * gecoApp::removeGecoIOModule.
 *
 * All loaded gecoIOModule can be listed with the Tcl command 'lsiomod'.
 *
 * The gecoApp makes available the following geco IO-modules in its Tcl interpreter by calling the method
 * gecoApp::registerNewCmd during it's construction:
 *
 * Geco IO-module   | Tcl Command
 * ---------------- | -------------
 * gecoIOTcp        | iotcp
 *
 * Geco packages
 * -------------
 * A new loaded geco package needs to be registered into the gecoApp with the method gecoApp::addGecoPkgHandle. 
 * New geco packages can be loaded into the Tcl interpreter by gecoApp with the Tcl command  
 * 'loadGecoPkg' defined by gecoApp. This command takes care of the registration to the gecoApp.
 * Once no longer needed, a gecoPkgHandle must be unregistered with the method gecoApp::removeGecoPkgHandle.
 * The command 'unloadGecoPkg' will remove the package from the Tcl interpreter and take care of 
 * unregistering it from the gecoApp.
 *
 * The Tcl command 'lsgecopkg' can be used to list all loaded geco packages.
 *
 * Example
 * -------
 * The following example creates a simple application with a command line interface to the geco library.
 * It demonstrates as well how to integrate a new gecoObj (see the documentation of gecoObj for the 
 * definition of this new gecoObj).
 * \include gecoAppEx.cc
 * 
 */


class gecoApp
{

  friend void geco_eventLoop(ClientData clientData);
  friend void geco_exitHandler(ClientData clientData);

protected:

  Tcl_Interp*     interp;                /*!< Tcl interpreter run by gecoApp */

  gecoProcess*    firstGecoProcess;      /*!< Start of the geco process loop */
  gecoIOModule*   firstGecoIOModule;     /*!< Start of the internal list of loaded gecoIOModule */
  gecoPkgHandle*  firstGecoPkgHandle;    /*!< Start of the internal list of loaded gecoPkgHandle */
  gecoTcpServer*  firstGecoTcpServer;    /*!< Start of the internal list of running gecoTcpServer */
  gecoEvent*      event;                 /*!< gecoEvent of the geco event loop */

  char*           prompt;                /*!< Prompt of the command line interface. Linked to the Tcl variable '::geco::prompt' */
  char*           commentStr;            /*!< Needed for internal purposes */

  void registerNewCmd();
  void registerGlobalVars();


public:

  gecoApp(int argc, char **argv);
  ~gecoApp();

  gecoProcess*   getFirstGecoProcess() {return firstGecoProcess;}  /*!< Returns first gecoProcess from the geco event loop */
  void           addGecoProcess(gecoProcess* proc);  
  int            moveGecoProcess(const char* PID1, const char* PID2);
  void           removeGecoProcess(gecoProcess* proc);
  gecoProcess*   findGecoProcess(const char* PID);

  gecoIOModule*  getFirstGecoIOModule() {return firstGecoIOModule;} /*!< Returns first gecoIOModule loaded in the gecoApp */
  void           addGecoIOModule(gecoIOModule* mod);  
  void           removeGecoIOModule(gecoIOModule* mod);  
  gecoIOModule*  findGecoIOModule(const char* cmd);

  gecoPkgHandle* getFirstGecoPkgHandle()    {return firstGecoPkgHandle;} /*!< Return the gecoPkgHandle of the first geco Package loaded */
  void           addGecoPkgHandle(gecoPkgHandle* handle);
  void           removeGecoPkgHandle(gecoPkgHandle* handle);  
  gecoPkgHandle* findGecoPkgHandle(const char* pkgName);
  
  gecoTcpServer* getFirstGecoTcpServer() {return firstGecoTcpServer;} /*!< Returns first TCP server running in the gecoApp */
  void           addGecoTcpServer(gecoTcpServer* srv);
  void           removeGecoTcpServer(gecoTcpServer* srv);
  int            gecoServerExist(gecoTcpServer* srv);

  gecoEvent*     getEvent()  {return event;}  /*!< Returns the gecoEvent of the geco event loop run by the gecoApp */
  Tcl_Interp*    getInterp() {return interp;} /*!< Returns the Tcl interpreter run by the gecoApp */

  void run();
  void runCLI();
};

#endif /* gecoApp_SEEN_ */
