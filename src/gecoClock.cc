// $Id: ECIO.cc 37 2015-01-09 12:35:29Z wuthrich $
// ---------------------------------------------------------------
//
// Definition of the class gecoClock
//
// (c) Rolf Wuthrich
//     2015 - 2020 Concordia University
//
// author:  Rolf Wuthrich
// email:   rolf.wuthrich@concordia.ca
// version: v1 ($Revision: 37 $)
//
// This software is copyright under the BSD license
//  
// ---------------------------------------------------------------
// history:
// ---------------------------------------------------------------
// Date       Modification                     Author
// ---------------------------------------------------------------
// 25.10.2015 Creation                         R. Wuthrich
// 08.12.2020 Added doxygen documentation      R. Wuthrich
//
// ---------------------------------------------------------------

#include <tcl.h>
#include <math.h>
#include <cstring>
#include "gecoEvent.h"
#include "gecoClock.h"

using namespace std;


// ---------------------------------------------------------------
//
// class gecoClock : class responsible for updating time
//


/**
 * @brief Constructor
 * @param App gecoApp in which the gecoClock lives 
 *
 * The constructor will create the Tcl command 'clk' via the call of
 * the constructor of gecoObj. It further defines additional
 * subcommands.
*/

gecoClock::gecoClock(gecoApp* App) :
  gecoObj("Clock", "clk", App, false),
  gecoProcess("Clock", "system", "clk", App)
{
  activateOnStart = 1;
  holdOn = 0;
  holdDuration = 0.0;
  tick = 1;

  // initialization of IO operation statistics
  min = 1e6;
  max = 0.0;
  sum_dt = 0.0;
  sqr_sum_dt = 0.0;
  n = 0;

  // options
  addOption("-IOStat", "returns statistics on IO operations");
  addOption("-tick", &tick, "returns/sets clock tick (ms)");
  addOption("-reset", "resets the clock");
}


/**
 * @brief Destructor
*/

gecoClock::~gecoClock()
{
}


/*! 
 * @copydoc gecoProcess::cmd
 *
 * Compared to gecoProcess::cmd, gecoClock::cmd adds the processing of
 * the new subcommands of gecoClock.
 */

int gecoClock::cmd(int &i, int objc,Tcl_Obj *const objv[])
{
  // first executes the command options defined in gecoProcess
  int index=gecoProcess::cmd(i,objc,objv);

  if (index==getOptionIndex("-reset"))
    {
     if (objc!=2)
	{
	  Tcl_WrongNumArgs(interp, 2, objv, NULL);
	  return -1;
	}
     reset();
     i = objc;
    }

  if (index==getOptionIndex("-IOStat"))
    {
     if (objc!=2)
	{
	  Tcl_WrongNumArgs(interp, 2, objv, NULL);
	  return -1;
	}
     iostat();
     i = objc;
    }

  return index;
}


/**
 * @copydoc gecoProcess::handleEvent
 *
 * In addition to gecoProcess::handleEvent, gecoClock::handleEvent implements
 * the correct updating of the time carried by the gecoEvent and
 * the appropriate actions to the geco events CmdStart, CmdHold, 
 * CmdResume and CmdStop which are generated by the Tcl commands 'start'
 * 'hold', 'resume' and 'stop'.
 *
 * Additional reaction to geco events
 * ----------------------------------
 *
 * geco event            | Action
 * --------------------- | ----------------------
 * CmdStart              | calls gecoClock::reset and sets the time in the gecoEvent to 0 and the gecoEvent loop status to 1
 * CmdHold               | calls gecoClock::hold
 * CmdResume             | calls gecoClock::resume
 * CmdStop               | sets the gecoEvent loop status to 0
 */

void gecoClock::handleEvent(gecoEvent* ev)
{
  // checks if new experiment started
  if (ev->cmd()==CmdStart)
    {
      ev->setEventLoopStatus(1);
      status = Active;
      reset();
      ev->setT(0.0);
    }

  gecoProcess::handleEvent(ev);

  // checks if loop is stopped
  if (ev->cmd()==CmdStop) ev->setEventLoopStatus(0);

  // checks if loop has to be hold
  if (ev->cmd()==CmdHold) hold();

  // checks if loop has to be resumed
  if (ev->cmd()==CmdResume) resume();

  // if not running or on hold nothing more to do
  if ((ev->eventLoopStatus()==0)||holdOn) return;

  // computes time since activated and corrects for hold-time
  struct timeval tv;
  gettimeofday(&tv, NULL);
  double t = tv.tv_sec-activationTime.tv_sec+
    (tv.tv_usec-activationTime.tv_usec)*1e-6-holdDuration;
  addStatReco(t-ev->getT());
  ev->setT(t);
  Tcl_UpdateLinkedVar(interp, "t");
}


/**
 * @copydoc gecoProcess::info
 *
 * In addition to gecoProcess::info, gecoClock::info adds the information
 * about the tick value.
 */ 

Tcl_DString* gecoClock::info(const char* frontStr)
{
  gecoProcess::info(frontStr);
  addInfo(frontStr, "Tick:\t", tick);  
  return infoStr;
}


/**
 * @brief adds an entry to the statistics about the geco process loop execution
 * @param dt time interval (ms) since run of the previous loop of the geco process loop
*/

void gecoClock::addStatReco(double dt)
{
  if (min>dt) min=dt;
  if (max<dt) max=dt;
  n++;
  sum_dt=sum_dt+dt;
  sqr_sum_dt=sqr_sum_dt+dt*dt;
}


/**
 * @brief resets the clock
*/

void gecoClock::reset()
{
  holdDuration = 0.0;

  // initialization of IO operation statistics
  min = 1e6;
  max = 0.0;
  sum_dt = 0.0;
  sqr_sum_dt = 0.0;
  n = 0;

  // record time origin
  gettimeofday(&activationTime, NULL);
}


/**
 * @brief holds the geco process loop
*/

void gecoClock::hold()
{
  if (holdOn) return;
  holdOn = 1;
  gettimeofday(&holdTime, NULL);
}


/**
 * @brief resumes the geco process loop
*/

void gecoClock::resume()
{
  if (!holdOn) return;
  holdOn = 0;
  // computes hold duration
  struct timeval tv;
  gettimeofday(&tv, NULL);
  holdDuration = tv.tv_sec-holdTime.tv_sec+
    (tv.tv_usec-holdTime.tv_usec)*1e-6+holdDuration;
}


/**
 * @brief returns statistics about the geco process loop execution
*/

void gecoClock::iostat()
{
  Tcl_ResetResult(interp);
  char   str[80];

  Tcl_Eval(interp, "format \"Run time = $t s\n\"");
  sprintf(str, "Number of IO operations : %d\n", n);
  Tcl_AppendResult(interp, str, NULL);

  Tcl_AppendResult(interp, "<dt>     = ", NULL);
  Tcl_PrintDouble(interp, 1000.0*(sum_dt/n), str);
  Tcl_AppendResult(interp, str," ms\n", NULL);

  Tcl_AppendResult(interp, "std dev  = ", NULL);
  Tcl_PrintDouble(interp, 1000.0*sqrt(sqr_sum_dt-sum_dt*sum_dt/n)/(n-1), str);
  Tcl_AppendResult(interp, str," ms\n", NULL);

  Tcl_AppendResult(interp, "min      = ", NULL);
  Tcl_PrintDouble(interp, 1000.0*min/n*n, str);
  Tcl_AppendResult(interp, str, " ms\n", NULL);

  Tcl_AppendResult(interp, "max      = ", NULL);
  Tcl_PrintDouble(interp, 1000.0*max/n*n, str);
  Tcl_AppendResult(interp, str, " ms\n", NULL);
}
